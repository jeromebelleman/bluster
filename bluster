#! /usr/bin/env python

'''
Blender cluster
'''

import sys
import os
import argparse
import pipes
import subprocess
import threading
import queue

import paramiko
import pgmagick
import yaml

def tprint(lock, msg):
    '''
    Thread-safe print
    '''

    lock.acquire()
    print msg
    lock.release()


def connect(cfg, lock, node, key):
    '''
    Connect to node
    '''

    tprint(lock, "%s: Opening SSH connection" % node)
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    proxy = paramiko.ProxyCommand('ssh %s nc %s 22' % (cfg['proxy'], node))
    client.connect(hostname=node, username='root', pkey=key, sock=proxy)
    sftp = client.open_sftp()

    return client, sftp


def install(cfg, lock, node, client):
    '''
    Install Blender
    '''

    cmd = 'ls .bluster/blender-* | grep -v bz2'
    _, stdout, _ = client.exec_command(cmd)

    if stdout.channel.recv_exit_status() == 0:
        if cfg['verbose']:
            tprint(lock, "%s: Blender is already available" % node)
    else:
        tprint(lock, "%s: Installing bzip2" % node)
        cmd = 'yum -y install bzip2'
        _, stdout, _ = client.exec_command(cmd)
        stdout.read()

        tprint(lock, "%s: Downloading Blender" % node)
        cmd = 'cd .bluster; curl -LO %s' % pipes.quote(cfg['url'])
        _, stdout, _ = client.exec_command(cmd)
        stdout.read()

        tprint(lock, "%s: Extracting Blender tarball" % node)
        cmd = 'cd .bluster; tar xf blender-*.tar.bz2'
        _, stdout, _ = client.exec_command(cmd)
        stdout.read()

        tprint(lock, "%s: Removing Blender tarball" % node)
        cmd = 'cd .bluster; rm blender-*.tar.bz2'
        _, stdout, _ = client.exec_command(cmd)
        stdout.read()


def render(cfg, lock, bpy, inputfile, node, client, sftp, region):
    '''
    Render region
    '''

    dry = os.path.basename(inputfile[:-6])
    outpath = '%s/%s.png' % (dry, '-'.join(region))

    if node == 'master':
        cmd = [
            'blender',
            os.path.expanduser(inputfile),
            '-b',
            '-P', os.path.expanduser(bpy),
            '--',
        ] \
        + region \
        + [os.path.expanduser('~/.bluster/%s' % outpath)]

    else:
        cmd = [
            'cd', '.bluster;',
            'blender-*/blender',
            pipes.quote('%s/%s' % (dry, os.path.basename(inputfile))),
            '-b',
            '-P', 'blender.py',
            '--',
        ] \
        + region \
        + [pipes.quote(outpath)]

    if cfg['verbose']:
        tprint(lock, '%s: %s' % (node, ' '.join(cmd)))
    else:
        tprint(lock, '%s: %s' % (node, region))

    if node == 'master':
        with open(os.devnull) as null:
            subprocess.call(cmd, stdout=null, stderr=null)
    else:
        _, stdout, _ = client.exec_command(' '.join(cmd))
        stdout.read()

    # Retrieve result
    if node != 'master':
        sftp.get('.bluster/%s' % outpath,
                 os.path.expanduser('~/.bluster/%s' % outpath))


def run(cfg, lock, bpy, regions, node, key, inputfile):
    '''
    Set up worker node and render region
    '''

    # Open SSH connection
    client = None
    sftp = None
    if node != 'master':
        try:
            client, sftp = connect(cfg, lock, node, key)
        except (paramiko.AuthenticationException, paramiko.SSHException), exc:
            tprint(lock, "%s: %s" % (node, exc))
            return

    # Make directories
    if node != 'master':
        dry = os.path.basename(inputfile[:-6])
        cmd = 'mkdir -p .bluster/%s' % pipes.quote(dry)
        _, stdout, _ = client.exec_command(cmd)
        stdout.read()

    # Install Blender if needs be
    if node != 'master':
        install(cfg, lock, node, client)

    # Copy files
    if node != 'master':
        copy(lock, node, sftp, bpy, '.bluster')
        copy(lock, node, sftp, inputfile, '.bluster/%s' % dry)

    # Consume region queue
    while True:
        region = regions.get()
        if region:
            # Render
            render(cfg, lock, bpy, inputfile, node, client, sftp, region)
        else:
            break

        regions.task_done()


def copy(lock, node, sftp, srcfile, dstdir):
    '''
    Copy if needs be
    '''

    dstfile = '%s/%s' % (dstdir, os.path.basename(srcfile))
    srctime = os.stat(srcfile).st_mtime
    try:
        dsttime = sftp.stat(dstfile).st_mtime
        if srctime > dsttime:
            raise IOError
    except IOError:
        tprint(lock, "%s: Copying %s" % (node, srcfile))
        sftp.put(srcfile, dstfile)


def main():
    '''
    Run
    '''

    # Parse arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('region', type=int, help="region size (%)")
    parser.add_argument('input', help="input Blender file")
    parser.add_argument('output', help="output PNG file")
    parser.add_argument('--bpy', default='/usr/share/bluster/blender.py',
                        help="Blender Python file")
    args = parser.parse_args()

    # Load config
    blusterdir = os.path.expanduser('~/.bluster')
    with open('%s/bluster.yaml' % blusterdir) as fhl:
        cfg = yaml.load(fhl)

    # Make directory on master
    stitchdir = '%s/%s' % (blusterdir, os.path.basename(args.input[:-6]))
    try:
        os.mkdir(stitchdir)
    except OSError:
        pass

    # Load private key
    key = paramiko.RSAKey.from_private_key_file(os.path.expanduser(cfg['key']))

    # Collect regions
    regions = queue.Queue()
    for i in range(0, 100, args.region):
        for j in range(0, 100, args.region):
            min_x = '%s' % (i / 100.)
            min_y = '%s' % (j / 100.)
            max_x = '%s' % (min(i + args.region, 100) / 100.)
            max_y = '%s' % (min(j + args.region, 100) / 100.)
            regions.put([min_x, min_y, max_x, max_y])

    # Run worker nodes
    lock = threading.Lock()
    threads = []
    for node in cfg['nodes']:
        prms = cfg, lock, args.bpy, regions, node, key, args.input
        thread = threading.Thread(target=run, args=prms)
        thread.start()
        threads.append(thread)
    regions.join()

    for _ in cfg['nodes']:
        regions.put(None)

    for thread in threads:
        thread.join()

    # Stitch images together
    entries = [ent for ent in os.listdir(stitchdir) if ent.endswith('.png')]
    base = pgmagick.Image('%s/%s' % (stitchdir, entries[0]))
    for ent in entries[1:]:
        layer = pgmagick.Image('%s/%s' % (stitchdir, ent))
        base.composite(layer, 0, 0, pgmagick.CompositeOperator.OverCompositeOp)
    base.write(args.output)

    # Clean up
    if 'cleanup' in cfg and cfg['cleanup']:
        for ent in entries:
            os.remove('%s/%s' % (stitchdir, ent))


if __name__ == '__main__':
    sys.exit(main())
