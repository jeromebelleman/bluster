#! /usr/bin/env python

'''
Blender cluster
'''

import sys
import os
import argparse
import pipes
import subprocess
import threading
import queue

import paramiko
import pgmagick
import yaml
import urwid


LOCK = threading.Lock()
WGTS = {'progress': {}}

def settext(pipe, node, msg):
    '''
    Thread-safe set text
    '''

    LOCK.acquire()
    os.write(pipe, '%s,%s' % (node, msg))


def connect(cfg, key, pipe, node):
    '''
    Connect to node
    '''

    settext(pipe, node, "Connecting")
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    proxy = paramiko.ProxyCommand('ssh %s nc %s 22' % (cfg['proxy'], node))
    client.connect(hostname=node, username='root', pkey=key, sock=proxy)
    sftp = client.open_sftp()

    return client, sftp


def install(cfg, pipe, node, client):
    '''
    Install Blender
    '''

    cmd = 'ls .bluster/blender-* | grep -v bz2'
    _, stdout, _ = client.exec_command(cmd)

    if stdout.channel.recv_exit_status() == 0:
        if cfg['verbose']:
            settext(pipe, node, "Blender is already available")
    else:
        settext(pipe, node, "Installing bzip2")
        cmd = 'yum -y install bzip2'
        _, stdout, _ = client.exec_command(cmd)
        stdout.read()

        settext(pipe, node, "Downloading Blender")
        cmd = 'cd .bluster; curl -LO %s' % pipes.quote(cfg['url'])
        _, stdout, _ = client.exec_command(cmd)
        stdout.read()

        settext(pipe, node, "Extracting Blender tarball")
        cmd = 'cd .bluster; tar xf blender-*.tar.bz2'
        _, stdout, _ = client.exec_command(cmd)
        stdout.read()

        settext(pipe, node, "Removing Blender tarball")
        cmd = 'cd .bluster; rm blender-*.tar.bz2'
        _, stdout, _ = client.exec_command(cmd)
        stdout.read()


def render(cfg, pipe, bpy, inputfile, node, client, sftp, region):
    '''
    Render region
    '''

    dry = os.path.basename(inputfile[:-6])
    outpath = '%s/%s.png' % (dry, '-'.join(region))

    if node == 'master':
        cmd = [
            'blender',
            os.path.expanduser(inputfile),
            '-b',
            '-P', os.path.expanduser(bpy),
            '--',
        ] \
        + region \
        + [os.path.expanduser('~/.bluster/%s' % outpath)]

    else:
        cmd = [
            'cd', '.bluster;',
            'blender-*/blender',
            pipes.quote('%s/%s' % (dry, os.path.basename(inputfile))),
            '-b',
            '-P', 'blender.py',
            '--',
        ] \
        + region \
        + [pipes.quote(outpath)]

    if cfg['verbose']:
        settext(pipe, node, ' '.join(cmd))
    else:
        settext(pipe, node, "Rendering region [%s]" % ', '.join(region))

    if node == 'master':
        with open(os.devnull) as null:
            subprocess.call(cmd, stdout=null, stderr=null)
    else:
        _, stdout, _ = client.exec_command(' '.join(cmd))
        stdout.read()

    # Retrieve result
    if node != 'master':
        settext(pipe, node, "Downloading output for [%s]" % ', '.join(region))
        sftp.get('.bluster/%s' % outpath,
                 os.path.expanduser('~/.bluster/%s' % outpath))

    settext(pipe, node, "Done with [%s]" % ', '.join(region))


def run(cfg, pipe, bpy, regions, node, key, inputfile):
    '''
    Set up worker node and render region
    '''

    # Open SSH connection
    client = None
    sftp = None
    if node != 'master':
        try:
            client, sftp = connect(cfg, key, pipe, node)
        except (paramiko.AuthenticationException, paramiko.SSHException), exc:
            settext(pipe, node, exc)
            return

    # Make directories
    if node != 'master':
        dry = os.path.basename(inputfile[:-6])
        cmd = 'mkdir -p .bluster/%s' % pipes.quote(dry)
        _, stdout, _ = client.exec_command(cmd)
        stdout.read()

    # Install Blender if needs be
    if node != 'master':
        install(cfg, pipe, node, client)

    # Copy files
    if node != 'master':
        copy(pipe, node, sftp, bpy, '.bluster')
        copy(pipe, node, sftp, inputfile, '.bluster/%s' % dry)

    # Consume region queue
    while True:
        if regions.empty():
            settext(pipe, node, '')
        region = regions.get()
        if region:
            # Render
            render(cfg, pipe, bpy, inputfile, node, client, sftp, region)
        else:
            break

        regions.task_done()


def copy(pipe, node, sftp, srcfile, dstdir):
    '''
    Copy if needs be
    '''

    dstfile = '%s/%s' % (dstdir, os.path.basename(srcfile))
    srctime = os.stat(srcfile).st_mtime
    try:
        dsttime = sftp.stat(dstfile).st_mtime
        if srctime > dsttime:
            raise IOError
    except IOError:
        settext(pipe, node, "Copying %s" % srcfile)
        sftp.put(srcfile, dstfile)


def join(cfg, pipe, regions, threads):
    '''
    Join threads
    '''

    regions.join()

    for _ in cfg['nodes']:
        regions.put(None)

    for thread in threads:
        thread.join()

    settext(pipe, 'exit', 'exit')


def update(data):
    '''
    Update user interface
    '''

    node, msg = data.split(',', 1)
    LOCK.release()

    if node == 'exit' and msg == 'exit':
        raise urwid.ExitMainLoop()
    else:
        if msg.startswith('Done'):
            total = WGTS['progress']['total']
            WGTS['progress']['progress'] += 1
            progress = WGTS['progress']['progress'] / total * 100
            WGTS['progress']['widget'].set_completion(progress)

        WGTS[node].set_text(msg)


def main():
    '''
    Run
    '''

    # Parse arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('input', help="input Blender file")
    parser.add_argument('output', help="output PNG file")
    parser.add_argument('--bpy', default='/usr/share/bluster/blender.py',
                        help="Blender Python file")
    args = parser.parse_args()

    # Load config
    blusterdir = os.path.expanduser('~/.bluster')
    with open('%s/bluster.yaml' % blusterdir) as fhl:
        cfg = yaml.load(fhl)

    # Set up user interface
    palette = [
        ('normal', 'white', 'black'),
        ('complete', 'white', 'dark gray'),
    ]

    grid = urwid.GridFlow([], 50, 1, 1, 'left')
    pile = urwid.Pile([grid])
    loop = urwid.MainLoop(urwid.Filler(pile), palette)
    pipe = loop.watch_pipe(update)

    # Make directory on master
    stitchdir = '%s/%s' % (blusterdir, os.path.basename(args.input[:-6]))
    try:
        os.mkdir(stitchdir)
    except OSError:
        pass

    # Load private key
    key = paramiko.RSAKey.from_private_key_file(os.path.expanduser(cfg['key']))

    # Collect regions
    regions = queue.Queue()
    for i in range(0, 100, cfg['region']):
        for j in range(0, 100, cfg['region']):
            min_x = '%s' % (i / 100.)
            min_y = '%s' % (j / 100.)
            max_x = '%s' % (min(i + cfg['region'], 100) / 100.)
            max_y = '%s' % (min(j + cfg['region'], 100) / 100.)
            regions.put([min_x, min_y, max_x, max_y])

    WGTS['progress']['widget'] = urwid.ProgressBar('normal', 'complete')
    WGTS['progress']['total'] = regions.qsize()
    WGTS['progress']['progress'] = 0.
    pile.contents.append((WGTS['progress']['widget'], pile.options()))

    # Run worker nodes
    threads = []
    for node in cfg['nodes']:
        # Set up widgets
        WGTS[node] = urwid.Text('')
        box = urwid.LineBox(WGTS[node], node)
        grid.contents.append((box, grid.options()))

        # Start thread
        prms = cfg, pipe, args.bpy, regions, node, key, args.input
        thread = threading.Thread(target=run, args=prms)
        thread.start()
        threads.append(thread)

    # Join threads
    thread = threading.Thread(target=join, args=(cfg, pipe, regions, threads))
    thread.start()

    loop.run()
    thread.join()

    # Stitch images together
    entries = [ent for ent in os.listdir(stitchdir) if ent.endswith('.png')]
    base = pgmagick.Image('%s/%s' % (stitchdir, entries[0]))
    for ent in entries[1:]:
        layer = pgmagick.Image('%s/%s' % (stitchdir, ent))
        base.composite(layer, 0, 0, pgmagick.CompositeOperator.OverCompositeOp)
    base.write(args.output)

    # Clean up
    if 'cleanup' in cfg and cfg['cleanup']:
        for ent in entries:
            os.remove('%s/%s' % (stitchdir, ent))


if __name__ == '__main__':
    sys.exit(main())
